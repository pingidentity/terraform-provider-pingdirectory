package ldapsdkdebuglogger

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	client "github.com/pingidentity/pingdirectory-go-client/v9300/configurationapi"
	"github.com/pingidentity/terraform-provider-pingdirectory/internal/resource/config"
	internaltypes "github.com/pingidentity/terraform-provider-pingdirectory/internal/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &ldapSdkDebugLoggerDataSource{}
	_ datasource.DataSourceWithConfigure = &ldapSdkDebugLoggerDataSource{}
)

// Create a Ldap Sdk Debug Logger data source
func NewLdapSdkDebugLoggerDataSource() datasource.DataSource {
	return &ldapSdkDebugLoggerDataSource{}
}

// ldapSdkDebugLoggerDataSource is the datasource implementation.
type ldapSdkDebugLoggerDataSource struct {
	providerConfig internaltypes.ProviderConfiguration
	apiClient      *client.APIClient
}

// Metadata returns the data source type name.
func (r *ldapSdkDebugLoggerDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ldap_sdk_debug_logger"
}

// Configure adds the provider configured client to the data source.
func (r *ldapSdkDebugLoggerDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerCfg := req.ProviderData.(internaltypes.ResourceConfiguration)
	r.providerConfig = providerCfg.ProviderConfig
	r.apiClient = providerCfg.ApiClientV9300
}

type ldapSdkDebugLoggerDataSourceModel struct {
	// Id field required for acceptance testing framework
	Id                             types.String `tfsdk:"id"`
	Description                    types.String `tfsdk:"description"`
	Enabled                        types.Bool   `tfsdk:"enabled"`
	LogFile                        types.String `tfsdk:"log_file"`
	DebugLevel                     types.String `tfsdk:"debug_level"`
	DebugType                      types.Set    `tfsdk:"debug_type"`
	IncludeStackTrace              types.Bool   `tfsdk:"include_stack_trace"`
	LogFilePermissions             types.String `tfsdk:"log_file_permissions"`
	TimeInterval                   types.String `tfsdk:"time_interval"`
	AutoFlush                      types.Bool   `tfsdk:"auto_flush"`
	Asynchronous                   types.Bool   `tfsdk:"asynchronous"`
	QueueSize                      types.Int64  `tfsdk:"queue_size"`
	BufferSize                     types.String `tfsdk:"buffer_size"`
	Append                         types.Bool   `tfsdk:"append"`
	RotationPolicy                 types.Set    `tfsdk:"rotation_policy"`
	RotationListener               types.Set    `tfsdk:"rotation_listener"`
	RetentionPolicy                types.Set    `tfsdk:"retention_policy"`
	CompressionMechanism           types.String `tfsdk:"compression_mechanism"`
	SignLog                        types.Bool   `tfsdk:"sign_log"`
	EncryptLog                     types.Bool   `tfsdk:"encrypt_log"`
	EncryptionSettingsDefinitionID types.String `tfsdk:"encryption_settings_definition_id"`
	TimestampPrecision             types.String `tfsdk:"timestamp_precision"`
	LoggingErrorBehavior           types.String `tfsdk:"logging_error_behavior"`
}

// GetSchema defines the schema for the datasource.
func (r *ldapSdkDebugLoggerDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Describes a Ldap Sdk Debug Logger.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "Name of this object.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"description": schema.StringAttribute{
				Description: "A description for this LDAP SDK Debug Logger",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"enabled": schema.BoolAttribute{
				Description: "Indicates whether this LDAP SDK Debug Logger is enabled.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"log_file": schema.StringAttribute{
				Description: "The path and base name of the file to use for log files generated by this LDAP SDK Debug Logger. The path may be either absolute or relative to the server root.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"debug_level": schema.StringAttribute{
				Description: "The minimum debug level that should be used for messages to be logged.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"debug_type": schema.SetAttribute{
				Description: "The types of debug messages that should be logged.",
				Required:    false,
				Optional:    false,
				Computed:    true,
				ElementType: types.StringType,
			},
			"include_stack_trace": schema.BoolAttribute{
				Description: "Indicates whether a stack trace of the thread which called the debug method should be included in debug log messages.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"log_file_permissions": schema.StringAttribute{
				Description: "The UNIX permissions of the log files created by this LDAP SDK Debug Logger.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"time_interval": schema.StringAttribute{
				Description: "Specifies the interval at which to check whether the log files need to be rotated.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"auto_flush": schema.BoolAttribute{
				Description: "Specifies whether to flush the writer after every log record.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"asynchronous": schema.BoolAttribute{
				Description: "Indicates whether the LDAP SDK Debug Logger will publish records asynchronously.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"queue_size": schema.Int64Attribute{
				Description: "The maximum number of log records that can be stored in the asynchronous queue.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"buffer_size": schema.StringAttribute{
				Description: "Specifies the log file buffer size.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"append": schema.BoolAttribute{
				Description: "Specifies whether to append to existing log files.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"rotation_policy": schema.SetAttribute{
				Description: "The rotation policy to use for the LDAP SDK Debug Logger .",
				Required:    false,
				Optional:    false,
				Computed:    true,
				ElementType: types.StringType,
			},
			"rotation_listener": schema.SetAttribute{
				Description: "A listener that should be notified whenever a log file is rotated out of service.",
				Required:    false,
				Optional:    false,
				Computed:    true,
				ElementType: types.StringType,
			},
			"retention_policy": schema.SetAttribute{
				Description: "The retention policy to use for the LDAP SDK Debug Logger .",
				Required:    false,
				Optional:    false,
				Computed:    true,
				ElementType: types.StringType,
			},
			"compression_mechanism": schema.StringAttribute{
				Description: "Specifies the type of compression (if any) to use for log files that are written.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"sign_log": schema.BoolAttribute{
				Description: "Indicates whether the log should be cryptographically signed so that the log content cannot be altered in an undetectable manner.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"encrypt_log": schema.BoolAttribute{
				Description: "Indicates whether log files should be encrypted so that their content is not available to unauthorized users.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"encryption_settings_definition_id": schema.StringAttribute{
				Description: "Specifies the ID of the encryption settings definition that should be used to encrypt the data. If this is not provided, the server's preferred encryption settings definition will be used. The \"encryption-settings list\" command can be used to obtain a list of the encryption settings definitions available in the server.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"timestamp_precision": schema.StringAttribute{
				Description: "Specifies the smallest time unit to be included in timestamps.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
			"logging_error_behavior": schema.StringAttribute{
				Description: "Specifies the behavior that the server should exhibit if an error occurs during logging processing.",
				Required:    false,
				Optional:    false,
				Computed:    true,
			},
		},
	}
}

// Read a LdapSdkDebugLoggerResponse object into the model struct
func readLdapSdkDebugLoggerResponseDataSource(ctx context.Context, r *client.LdapSdkDebugLoggerResponse, state *ldapSdkDebugLoggerDataSourceModel, diagnostics *diag.Diagnostics) {
	// Placeholder id value required by test framework
	state.Id = types.StringValue("id")
	state.Description = internaltypes.StringTypeOrNil(r.Description, false)
	state.Enabled = types.BoolValue(r.Enabled)
	state.LogFile = types.StringValue(r.LogFile)
	state.DebugLevel = types.StringValue(r.DebugLevel.String())
	state.DebugType = internaltypes.GetStringSet(
		client.StringSliceEnumldapSdkDebugLoggerDebugTypeProp(r.DebugType))
	state.IncludeStackTrace = types.BoolValue(r.IncludeStackTrace)
	state.LogFilePermissions = types.StringValue(r.LogFilePermissions)
	state.TimeInterval = internaltypes.StringTypeOrNil(r.TimeInterval, false)
	state.AutoFlush = internaltypes.BoolTypeOrNil(r.AutoFlush)
	state.Asynchronous = types.BoolValue(r.Asynchronous)
	state.QueueSize = internaltypes.Int64TypeOrNil(r.QueueSize)
	state.BufferSize = internaltypes.StringTypeOrNil(r.BufferSize, false)
	state.Append = internaltypes.BoolTypeOrNil(r.Append)
	state.RotationPolicy = internaltypes.GetStringSet(r.RotationPolicy)
	state.RotationListener = internaltypes.GetStringSet(r.RotationListener)
	state.RetentionPolicy = internaltypes.GetStringSet(r.RetentionPolicy)
	state.CompressionMechanism = internaltypes.StringTypeOrNil(
		client.StringPointerEnumldapSdkDebugLoggerCompressionMechanismProp(r.CompressionMechanism), false)
	state.SignLog = internaltypes.BoolTypeOrNil(r.SignLog)
	state.EncryptLog = internaltypes.BoolTypeOrNil(r.EncryptLog)
	state.EncryptionSettingsDefinitionID = internaltypes.StringTypeOrNil(r.EncryptionSettingsDefinitionID, false)
	state.TimestampPrecision = internaltypes.StringTypeOrNil(
		client.StringPointerEnumldapSdkDebugLoggerTimestampPrecisionProp(r.TimestampPrecision), false)
	state.LoggingErrorBehavior = internaltypes.StringTypeOrNil(
		client.StringPointerEnumldapSdkDebugLoggerLoggingErrorBehaviorProp(r.LoggingErrorBehavior), false)
}

// Read resource information
func (r *ldapSdkDebugLoggerDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	// Get current state
	var state ldapSdkDebugLoggerDataSourceModel
	diags := req.Config.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	readResponse, httpResp, err := r.apiClient.LdapSdkDebugLoggerApi.GetLdapSdkDebugLogger(
		config.ProviderBasicAuthContext(ctx, r.providerConfig)).Execute()
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while getting the Ldap Sdk Debug Logger", err, httpResp)
		return
	}

	// Log response JSON
	responseJson, err := readResponse.MarshalJSON()
	if err == nil {
		tflog.Debug(ctx, "Read response: "+string(responseJson))
	}

	// Read the response into the state
	readLdapSdkDebugLoggerResponseDataSource(ctx, readResponse, &state, &resp.Diagnostics)

	// Set refreshed state
	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
}
